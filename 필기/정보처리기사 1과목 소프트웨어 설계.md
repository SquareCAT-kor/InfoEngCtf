# 정보처리기사 1과목 소프트웨어 설계

> 미숙지 개념 위주 필기 - UML , Coupling, Cohesion, Design Pattern, Abstraction 추상화

### 1.요구사항 - 소프트웨어 생명주기, 스크럼, XPe , UML

> 가장 폭넓게 사용되는 모델 ? : 폭포수 모형
>
> 점진적 모형 : Sprial 나선
>
> 구체화, 시각화 : 프로토타입

#### 소프트웨어 개발 모델

* 애자일 (Agile Model)

  * 소규모 프로젝트, 고도로 숙달된 개발자, 급변하는 요구사항
  * 스크럼(Scrum), XP(eXtreme Programming), 칸반(KanBan), Lean, Crystal, ASD, FDD, DSDM, DAD 등
  * 애자일 개발 4가지 핵심 가치
    1. 프로세스와 도구보다는 개인과 상호작용에 가치를
    2. 방대한 문서보다는 실행되는 SW에 가치를
    3. 계약 협상보다는 고객과 협업에 가치를
    4. 계획에 따르기보다는 변화에 반응하는 것에 가치를

* 애자일 - Scrum 기법

  > Burn down 차트 사용

  * 팀이 중심이 되어 개발의 효율성을 높인다.
  * 구성원
    * 제품 책임자 (PO Product Owner) : 제품 백로그 업데이트 담당
    * 스크럼마스터 (SM Scrum Master)
    * 개발팀 (DT Development Team)
  * 개발 프로세스
    * 제품 백로그 -> 스프린트 계획 회의 -> 스프린트 수행(2~4주) & 일일 스크럼 회의(매일진행, 15분 내외 짧은시간) -> 스프린트 검토 -> 스프린트 회고  

* 애자일 - XP (eXtreme Programming)

  * 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시킨다. 
  * 릴리즈의 기간을 짧게 반복하면서 고객의 요구사항 반영에 대한 가시성을 높인다.
  * 테스트마다 고객을 참여시킨다.
  * 소규모 인원의 개발 프로젝트에 효과적이다.
  * 5가지 핵심 가치 : 의사소통 (Communication), 단순성(Simplicity), 용기(Courage), 존중(Respect), 피드백(Feedback) - CSCRF
  * 개발 프로세스
    * 사용자 스토리 -> 릴리즈 계획 수립 -> 스파이크 [ -> 이터레이션 -> 승인 검사(사용자 참여 및 고객 승인 필요) -> 소규모 릴리즈  ] [ ]반복
    * 소규모 릴리즈를 반복하여 고객의 승인을 받으며 개발을 지속하는 형태.
  * 실천 방법 (몇가지만): 
    * Pair Programming ( 공동 책임 개발)	
    * Continuous Integration ( 지속 통합 )
    * Design Improvement & Refactoring 
    * Small Releases 

#### UML : Unified Modeling Language

* 개요 : 고객 , 개발자 상호간의 의사소통이 원활하게 이루어지도록 표준화한 대표적인 객체지향 모델링 언어. 
* 구성 : 6개의 구조 다이어그램과, 동작을 표현하는 7개의 행위 다이어그램  , ( 사물 , 관계 , 다이어그램)
* 사물(Things) 
  * 모델을 구성하는 가장 중요한 기본 요소 , 관계 성립의 대상
    1. 구조사물 : 개념적, 물리적 요소
       * 클래스, 유스케이스, 컴포넌트, 노드
    2. 행동사물 : 시간과 공간에 따른 요소들의 행위
       * 상호작용, 상태 머신
    3. 그룹 사물: 요소들을 그룹으로 묶어서 표현
       * 패키지
    4. 주해 사물(Annotation) : 부가적인 설명이나 제약조건
       * 노트 (Note)
* 관계(Relationships)
  * 연관 관계 : 2개 이상의 사물이 서로 관련있음.
    * 실선 표시, 방향성은 화살표 ( 양방향은 화살표 생략)
    * 연관된 객체의 개수 다중도(Multiplicity) 를 선 위에 표기
  * 집합 관계 Aggregation : 하나의 사물이 다른 사물에 포함되어 있는 관계
    * 포함하는 쪽(전체 whole)과 포함되는 쪽(part)은 서로 독립적
    * 포함되는 쪽(part)과 포함하는 쪽(whole)으로 **속이 빈 마름모**로 연결한다.
  * 포함 관계 : 포함하는 사물의 변화가 포함되는 사물에게 영향을 미치는 관계 
    * whole 과 part가 독립될 수 없고, 생명주기를 함께 함.
    * part에서 whole 쪽으로 **속이 채워진 마름모**를 연결
  * 일반화 관계 : 하나의 사물이 다른 사물에 비해 더 일반적인지 구체적인지를 표현
    * 일반적인 개념을 상위 (부모  Parent) , 구체적인 개념을 하위(자식 child)로 표현
    * child 에서 parent 방향으로 **속이 빈 화살표**
  * 의존 관계 Dependency : 서로 연관은 있으나 필요에 의해 서로에게 영향을 주는 짧은 시간 동안만 연관을 유지하는 관계
    * 영향을 주는 사물이 영향을 받는 사물 쪽으로 **점선 화살표**를 연결하여 표현 
    * (반드시 항상 영향을 주지 않는 관계 = 점선 )
  * 실체화 관계 : 사물이 할 수 있거나 해야 하는 기능(행위, 인터페이스) 으로 서로를 그룹화 할 수 있는 관계
    * 사물(things) 에서 기능 쪽으로 **점선 + 속이 빈 화살표**
* 다이어그램 (Diagram)
  * **구조적** 다이어그램 : 클래스(Class), 객체(Object), 컴포넌트(Component), 배치(Deployment), 복합체 구조(Composite Structure), 패키지(Package)
    * 구현단계 : 컴포넌트, 배치 다이어그램
  * **행위** 다이어그램 : 유스 케이스(UseCase), 시퀀스(Sequence), 커뮤니케이션(Communication), 상태(State),활동(Activity),상호작용 개요(Interaction Overview), 타이밍(Timing)



### 2.화면설계 - 인터페이스, 설계 도구, 프로토타입 등

* UI 설계 도구
  * 와이어프레임 Wireframe : 뼈대 제작 - 손그림,파워포인트,키노트,스케치 ... 
  * 목업 Mockup : 와이어프레임 보다 실제 화면에 가깝게 만든 모형 - 파워 목업, 발사믹 목업 ...
  * 스토리보드 Stroy Board : 와이어프레임에 컨텐츠 설명 추가 (Description 추가) - 파워포인트, 키노트, 스케치, Axure ...
  * 프로토타입 Prototype : 테스트 가능한 모형 - 페이퍼 or 디지털 : HTML, Axure, Flinto, 네이버 프로토나오, 카카오 오븐 ... *전체가 아닌 부분 테스트* 
  * 유스케이스 Use Case : 요구사항 정리, 다이어그램 형식으로 표시 - 유스케이스 명세서
* 품질 요구사항 종류 : 기능성 , 신뢰성 , 사용성, 효율성, 유지 보수성, 이식성  (ISO / IEC 9126, 25010 ...)
* UI 프로토타입 제작 단계 : 요구사항 분석 -> 프로토타입 작성 -> 사용자 확인 -> 수정과 합의 , 보완작업 반복



### 3. 애플리케이션 설계 - 소프트웨어 아키텍쳐, 패턴, 객체지향, 모듈

#### 소프트웨어 아키텍처

> 소프트웨어의 골격이 되는 기본 구조, 관계 표현 시스템의 구조 및 구조체

* 모듈화 : 기능을 모듈 단위로 나누어 재사용성 향상 
  * 모듈의 크기가 작아지면 통합 비용이 많이들고, 
  * 모듈의 크기가 커지면 통합 비용은 적게드나, 하나 개발하는 비용이 많이든다.
* 추상화 : 문제를 포괄적으로 설계 후 차례로 세분화하여 구체화 하는 과정 **개략화, 모델화** 
  * 유사 모델 작성 후 테스트, 시스템의 구조 및 구성을 대략적으로 파악
  * 유형 
    * 과정 추상화 : 흐름 파악 설계
    * 데이터 추상화 : 데이터 구조를 대표할 수 있는 표현으로 대체
    * 제어 추상화 : 이벤트 발생의 정확한 절차나 방법이 아닌 대표할 수 있는 표현으로 대체
* 단계적 분해 : 추상화를 반복하여 세분화 시키고 구체화시킨다. ( 기능에서 시작하여 구체화 )
* 정보 은닉 : 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법 , 필요한 정보만 주고받음, 수정 시험 유지보수 용이 **캡슐화와 다른 개념인듯** 
* 품질 속성 
  * 시스템 측면 : 성능, 보안 , 가용성 (장애 없이 서비스 제공), 기능성 (요구한 기능 구현), 사용성 (편리한 사용성), 변경 용이성(다른 하드웨어나 플랫폼), 확장성(용량,처리능력 확장 구현), 기타 (테스트용이,배치,안정)
  *  비즈니스 측면 : 시장 적시성(시간에 맞춘출시), 비용과 혜택(유연성이 높은 아키텍쳐)
  * 아키텍처 측면 : 개념적 무결성, 정확성과 연결성(제약 조건 충족), 구축 가능성 (유연한 일정 변경)
* 아키텍처 설계 과정
  1. 설계 목표 설정
  2. 시스템 타입 결정
  3. 아키텍처 패턴 적용
  4. 서브시스템 구체화
  5. 검토 

#### 아키텍처 패턴

> = 아키텍처 스타일, 표준 아키텍처 
>
> 아키텍처를 설계할 때 참조할 수 있는 전형적인 해결 방식 또는 예제
>
> 레이어 패턴, 클라이언트-서버 패턴, 파이프-필터 패턴, 모델-뷰-컨트롤러 패턴

* 레이어 패턴 Layers : 시스템을 계층으로 구분하여 구성하는 고전적 방식
  * OSI 참조모델
* 클라이언트-서버 패턴 Client-Server: 하나의 서버에 다수의 클라이언트 컴포넌트가 구성되는 패턴
* 파이프-필터 패턴 Pipe-filter: 데이터 스트림 절차의 각 단계를 필터 컴퓨넌트로 캡슐화하여 파이프를 통해 데이터를 전송 **하나의 컴포넌트에서 처리가 끝나면 다음 컴포넌트가 결과물을 받아서 처리** 
  * 파이프라인 구축, 재사용성이 좋고 추가가 쉽다. 
  * 데이터 변환, 버퍼링, 동기화 등에 사용
  * 대표예시 : 유닉스 쉘 
* 모델-뷰-컨트롤러 패턴  (MVC)
  * 모델 : 서브시스템의 핵심 기능과 데이터를 보관
  * 뷰 : 사용자에게 정보를 표시 (View , front)
  * 컨트롤러 : 사용자로부터 받은 입력 처리  ( UI, View control) 
  * 대화형 애플리케이션 , (SPRING 기반 웹앱 및 모바일앱 등)
* 기타 
  * 마스터-슬레이브 : 장애 허용 시스템 및 병렬 컴퓨팅
  * 브로커 패턴 : 분산환경 시스템
  * 피어 투 피어 패턴 : P2P **멀티스레딩** ( 컴포넌트들이 서버가 될수도 있고 클라이언트가 될수도 있는 형태)
  * 이벤트 버스 : 구독자들에게 메시지 뿌림, 리스너들이 받아서 처리 ( CAN BUS, FireBase CloudMessaging)
  * 블랙보드 패턴 : 음성인식, 차량식별, 신호해석 등
  * 인터프리터 패턴 : 특정 언어로 작성된 프로그램 코드를 해석하는 컴포넌트



#### 객체지향 Obejct-Oriented

* 현실세계를 모형화 , 사용자가 개발자가 쉽게 이해할 수 있다.
* 재사용 및 확장이 용이, 유지보수가 쉽다.
* 복잡한 구조를 단계적 & 계층적으로 표현, 병렬처리 지원

1. 객체 ( Object )

   데이터와 데이터를 처리하는 함수를 묶어 캡슐화한 하나의 소프트웨어 모듈

   데이터 : 속성, 상태, 분류 .. 

   함수 : 데이터 처리 알고리즘 - Method, Service, Operation, Expression 등

   * 특성 

     * 독립적 식별 가능한 이름 보유 - Unique

     * 상호 연관성에 의한 관계 형성 - Coupling ?  , 객체가 모여 기능을 형성

     * 객체가 반응할 수 있는 메시지의 집합 - 행위 (String.append, Thread.start .. 이런거)

     * 일정한 기억장소 보유

       

2. 클래스 ( Class ) 

   공통된 속성과 연산을 갖는 객체(Object) 의 집합 , 객체의 일반적인 Type

   * instance : 클래스에 속한 각각의 Object  / 클래스에서 새로운 Object를 생성하면 인스턴스화라고 함.
     * Class = Objects , Instance = Object 
     * ex ? : Class Math : Math.abs Math.sum, max, min 등등 ( Math class, abs,sum,max,min Object & Instance )
   * 최상위 클래스? : 상위 클래스가 없음. 
   * 슈퍼 클래스? : 특정 클래스의 상위 클래스

3. 캡슐화 ( Encapsulation)

   * 데이터와 데이터를 처리하는 함수를 하나로 묶는 것.
   * 재사용이 용이하다. 정보 은닉이 되어 외부접근이 제한적임
   * 인터페이스가 단순해지고, 결합도가 낮아지낟. (Coupling)

4. 상속 (Inheritance)

   * 이미 정의된 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받음. 
     * 소프트웨어의 재사용성을 높인다.
     * ex) Implements, extends  
       * extends : 부모클래스의 메소드와 변수를 사용, 여러 클래스 상속 불가
       * implements: 여러개의 인터페이스를 가져오고, 완성은 가져온 곳에서 한다. (이름과 반환타입만 가져옴)
     * 다중 상속이 가능. 첨가 가능

5. 다형성 

   * 메시지에 의해 Object가 연산을 수행할 때, Obejct(Class) 가 가지고 있는 고유한 방법으로 응답할 수 있는능력
   * 같은 메소드명을 사용하여 같은 의미의 응답을 한다.
     * ex ) String + String = String, Int + Int = Int / String + int   = String 

#### 모듈

> 시스템의 각 기능들, Subroutine, SubSystem, Unit 등으로 사용

* 단독 컴파일 가능, 재사용 가능
* 기능적 독립성 ?  : 소프트웨어를 구성하는 각 모듈의 기능이 서로 독립된다. - 과도한 상호작용을 배제한다.

1. 결합도 - Coupling  **낮을수록, 약할수록 좋다** / 자스제외공내

   모듈 사이의 연관 관계 : 결합도가 강할수록 시스템 구현 및 유지보수가 어려움.
   내려갈수록 결합도 강해짐 

   * 자료 결합도Data  - 모듈간 데이터만 주고받음 . 바람직 ( 데이터를 넘겨받고 결과만 데이터로 돌려주는 결합도)
   * 스탬프(검인)Stamp 결합도 : 동일한 데이터를 조회, 자료구조 변화 시 모듈 영향
   * 제어 결합도Control: 논리적인 흐름 제어, 통신 제어 전달 결합도 - 하위모듈에서 상위모듈을 제어하는 권리 전도현상이 발생
   * 외부 결합도External : 어떤 모듈의 데이터(변수)를 외부의 다른 모듈에서 참조
   * 공통 결합도Common : 공유되는 공통 영역을 여러 모듈이 사용 - 모듈의 독립성을 약하게 만듬
   * 내용 결합도 Content:  한 모듈이 다른 모듈의 내부 기능 및 자료를 직접 참조하거나 수정 - 모듈간 내부제어 - 결합도높음

   강한순 : 내공외제스자 (내공외제스데)

   약한순 : 자스제외공내 (데스제외공내)

2. 응집도 - Cohesion **강할수록 좋다** 기순교절시논우

   정보은닉 개념의 확장, 독립적인 기능으로 정의되어 있는 정도 

   응집도가 강할수록(독립적 기능이 많을수록) 품질이 높고, 약할수록 품질이 낮다.

   * 기능적 응집 > 순차적 응집 > 교환적 응집 > 절차적 응집 > 시간적 응집 > 논리적 응집 > 우연적 응집
   * Functional - Sequence - Communication - Procedure - Time - Logic - Coincidental

3. Fan in / Fan out

   * 팬인 : 어떤 모듈을 제어(호출)하는 모듈의 수 (머리에 꽂힌 가지)
   * 팬아웃 : 어떤 모듈에 의해 제어되는 모듈의 수 (뻗어나온 가지)

   시스템의 복잡도를 최적화하려면 팬인은 높게, 팬아웃은 낮게 

   

#### 코드 ( 프로그래밍 코드 아니고 식별부호)

* 코드의 기능 : 식별 분류 배열
* 코드의 종류 : 순차 (Sequence), 블록(Block), 10진, 그룹 분류, 연상, 표의 숫자, 합성 
* 코드 부여체계 : 개체의 용도와 적용 범위를 알 수 있도록 부여한다. PY3-MOD-010 등. 



#### 디자인 패턴

* 기본형 코드들을 포함한 패턴. 생성 패턴, 구조 패턴, 행위 패턴 등이 있음.
* Factory, Adapter, Prototype 등등 

#### 기출 및 예상문제 

* 제어 추상화 ? : 이벤트 발생의 구체적인 절차 또는 방법을 정의하지 않고 대표할수 있는 표현을 **대체**
* 정보 은폐의 목적? : 고려되지 않은 영향을 최소화하기 위해
* 설계 과정과 구현 과정을 분리해서 생각하기
* 아키텍처 설계 과정 : 목표설정 -> 시스템 ,서브시스템 타입 결정 -> 설계 -> 인터페이스 정의
* 레이어 패턴 : 상위 제공 하위 사용
* 끝나면 결과 이어받아 처리하는 아키텍처 : 파이프 필터
* 데이터 추상화 = 객체지향에서는 CLASS
* 내부 참조  = 내용 결합도
* 동일한 자료 구조 refer = 스탬프 결합 
* 매개변수, 인수 = 데이터 결합 
* 기능적 응집도 : 모듈안의 모든 요소들이 하나의 기능과 연관 / 다음 기능요소 xxxxxx
* 연관관계 없는경우 = 우연적 결합
* 공통 모듈설계 ? - 명확성, 정확성, 일관성, 완전성, 추적성.. 
* Mnemonic 코드 = 연상 코드 - 코드가 특정 사물을 연상되게하는 코드 
* Facade 패턴 : 복잡한 서브 클래스를 피해 더 상위에 인퍼테이스를 구성하여 서브 클래스들의 기능을 간편하게 사용한다.
* Singleton 패턴 : 하나의 객체를 생성하여 어디서든 참조
* Strategy : 필요할때마다 원하는 알고리즘을 선택하도록 하는 패턴 (네비게이션 경로찾기)
* 패턴의 성격 종류 ? : 
  구조적(Adapter,Composite,Facade,Decorator) 패턴,
   행위(State, Strategy, Memento ,Observer..) 패턴 
* Decorator : 장식하듯이 다른 부가기능을 덧붙이는방식 - 상속을 사용하지 않고도 객체의 기능을 동적으로 확장
*  상호작용 협력 : Mediator 패턴 

### 4. 인터페이스 설계- 미들웨어솔루션

#### 미들웨어 솔루션 명세

> 개념 및 종류 : 운영체제와 응용 프로그램 사이에서 OS 가 제공하는 기능 외의 것을 제공하는 소프트웨어
>
> DB, RPC, MOM, TP-Monitor, ORB, WAS 등

1. DB DataBase
2. RPC Remote Procedure Call : 프로시저를 사용하여 원격 프로시져를 마치 로컬 프로시져 처럼 호출
   * Procedure ? : 특정 기능을 수행하는 블록 PL/SQL 
3. MOM Message Oriented Middleware : 메시지 기반의 비동기형 메시지를 전달( 데이터 동기화 )
   * IBM MQ, Oracle Message Q ? 
4. TP- Monitor ( Transaction Processing Monitor) : 트랜색션 처리 모니터 
   * 사용자 수가 증가해도 빠른 응답 속도를 유지해야 하는 업무에 사용
5. ORB ( Object Request Broker) : 객체 지향 미들웨어,CORBA 표준스펙
   * 네트워크 분산 프로그램 객체 생성, 배포, 관리 
6. WAS (Web Application Server) : 동적인 콘텐트 처리용 미들웨어
   * HTTP 세션 처리, JAVA ,EJB 컴포넌트 기반 구현
7. 미들웨어 솔루션 식별 : 개발 및 운영 환경에 사용될 미들웨어 솔루션 확인 ,목록 작성
8. 미들웨어 솔루션 명세서 : 시스템, 운영 환경에서의 솔루션 목록을 상세하게 기술.

(솔루션 확인 후 명세서 작성 - 순서관련 문제가 나올???수도)

#### 예상문제

* 요구사항 검토 방법 : 인스펙션, 워크스루, 동료 검토
* 인터페이스 요구사항 검증 항목 : 명확성, 일관성, 가용성 
* 인터페이스 송 수신 데이터 식별 시 해당하는 데이터 종류 : 공통 코드, 인터페이스 표준 항목, 송수신 데이터 항목
* 지연처리방식은 데이터를 매건단위로 처리할 경우 비용이 많이 발생한다.
* 보안이 중요한 데이터 항목은 인터페이스 설계자나 운영자가 아닌, 기업이나 법률적 규정에 따라 암호화한다.
* 오류 코드는 오류발생 영역 구분자와, 오류 그룹 번호로 정의
* 시스템 인터페이스 ? : 연계 업무와 연계에 참여하는 송수신 시스템의 정보에 대한 정의 
* 개체 타입과 관련속성 및 식별자에 대한 정보 = 개체정의
* 인터페이스 요구사항 검증 및 변경은 절차에 따라 . 검증참여했던사람 ㄴㄴ







