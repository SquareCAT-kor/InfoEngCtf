# 정보처리기사 2과목 소프트웨어 개발

## 1장 데이터 입출력 구현

### 1. 자료구조

> 자료의 표현과 이와 관련된 연산
>
> 일련의 자료들을 조직하고 구조화 하는 것

* 선형 구조 : Array, Linear List(ContiguousList, LinkedList), Stack, Queue, Deque
  * ContiguousList? : 연결 리스트, 연속되는 기억장소에 저장되는 자료 
  * LinkedList? : 포인터를 이용하여 서로가 연결된 자료구조 != 순차적인 선형 구조는 아님!
* 비선형 구조 : Tree, Graph
  * Tree 
    * Degree : 가장 차수가 많은 노드의 Degree = 가장 가지가 많은 노드에서 가지의 개수
    * Terminal Node 단말 노드 : 가지가 없는 노드의 갯수 

### 2. 데이터베이스

* 데이터저장소 : 논리 데이터저장소(데이터 간의 연관성) , 물리 데이터저장소(하드웨어적인 저장장치)
* 데이터베이스 : 정의
  * 통합된 데이터 Integrated Data : 자료의 중복을 배제한 데이터의 모임 
  * 저장된 데이터 Stored Data: 저장 매체에 저장된 자료
  * 운영 데이터 Operational Data: 조직의 업무를 수행하는데 필수적인 데이터
  * 공용 데이터 Shared Data: 여러 응용 시스템들이 공동으로 소유하고 유지하는 자료
* DBMS : 데이터베이스 관리 시스템
  * 데이터의 종속성, 중복성 문제 해결
  * 구성, 접근방법, 유지관리에 대한 모든 책임
  * 정의 Definition 조작 Manipulation, 제어 Control 기능 !!!! 보안 기능은 필수가 아니다.
    * 정의 : 데이터 타입 및 구조 정의, 이용 방식, 제약 조건
    * 조작 : CRUD
    * 제어 : 권한 부여 및 병행제어 - 데이터 사용자 통제 및 보안과 조금 다른 말인가봄.. 
  * 궁극적 목표 : 데이터 독립성 - 데이터의 논리적 구조를 변경해도 응용프로그램은 변경되지 않으며, 물리적 장치를 독립 시켜 따로 관리하여 응용 프로그램에 영향을 주지 않는다.

### 3. 데이터 입출력 & SQL

* SQL - DDL (Data Define), DML (Data Manipulate), DCL (Data Control) , 정의 조작 제어
* 트랜섹션 Transaction - 일련의 연산, 작업 단위, 연산단위 등등.. 
  * Commit , Rollback , Savepoint = TCL  
  * Savepoint ? : 저장점은 언제든 위치를 정하고 필요시 롤백할 수 있다.

* 절차형 SQL : 연속적인 실행이나 분기, 반복 등의 제어가 가능한 SQL
  * Procedure  : 특정 기능을 수행하는 일종의 트랜섹션 언어 SQL에서는 호출을 통해 미리 저장해 놓은 작업을 수행
  * Trigger : 이벤트 발생시 관련 작업 수행
  * 사용자 정의 함수 : SQL에서 사용자가 만들어 사용하는 함수 ,프로시져와 비슷 ,
    Return 을 사용하여 결과 반환
* APM ? : 쿼리성능 측정도구 Application Performance Management/Monitoring



#### 예상문제

* Underflow? : 제거할 자료가 없는데 제거명령 내리면 발생
* 논리 데이터 저장소? : 데이터간의 연관성, 제약조건을 식별하여 논리적 구조로 조직화 한것.
* 데이터베이스 정의? : 공용 통합 저장 운영 공통저운
* DB 중복, 종속제거 = 통합된 데이터

### 2장 통합 구현

#### 예상 문제

* ICP : Inter-Process Communication : Shared Memeory, Socket, Semaphores, Pipes, Message Queueing
* Semaphores : 자원에 대한 접근 제어를 통해 프로세스 간 통신 지원
* 모듈 종류 : 디바이스 드라이버, 네트워크, 파일, 메모리, 프로세스
* 단위 테스트 - Unit Test? : 실행 전에 환경조성 필수
* 출력 명세? : 예상되는 출력 결과를 명세하는 것. 
* 테스트 케이스? : 테스트에 필요한 입력 데이터, 환경, 조건, 의존성, 예상결과  등을  기입한  문서
* 테스트 프로시져 ? : 테스트 케이스의 실행 순서 = Test Scripts
* 테스트 시나리오 ? : 테스트 케이스를 묶어서 수행에 대한 절차 명세
* Ant : Anoter Next Tool : 아파치 재단 소프트웨어, XML 기반 빌드, 정해진 규칙이나 표준 없음, Maven Gradle 로 dependency 라이브러리 관리

### 3장 소프트웨어 패키징

> 패키징, 릴리즈, DRM, Manual, 형상관리, GIt, Jenkins, Gradle 

* 소프트웨어 패키징 순서  ( 모듈별로 생성한 실행 파일들을 묶어서 배포용 설치 파일을 만든다.)
  1. 기능 식별 : 작성한 코드의 기능 확인
  2. 모듈화 : 기능 단위 분류
  3. 빌드진행 : 모듈 단위별 실행파일 구성
  4. 사용자 환경 분석 : 웹? 모바일? PC? CPU? RAM 등을 분석
  5. 패키징 및 적용시험 : 정의된 환경과 동일한 환경 테스팅, 사용자 입장 테스트
  6. 패키징 변경 개선 : 불편 사항 반영을 위한 개선
  7. 배포 : 오류 발생 시 수정요청 
     * msi, dmg, jar, war, ear, apk, ipa 등으로 배포 
* 릴리즈 Release 노트 : 소프트웨어 전체 기능, 서비스 내용, 개선 사항 등을 버전별로 작성하는것.
  * 오류 발생 시 관련 릴리즈 노트 작성은 필수임

#### 1. DRM 디지털 저작권 관리 

​	Digital Right Management  : 디지털 콘텐츠가 저작권자가 의도한 용도로만 사용되도록 디지털 콘텐츠의 생성, 유통, 이용까지의 전 과정에 걸쳐 사용되는 디지털 콘텐츠 관리 및 보호 기술

* 아날로그의 경우 디지털로 변환 후 Pacakager 에 의해 DRM 패키징 수행
* 패키징 수행 시 암호화된 저작권자의 전자서명이 포함되고, 라이선스 정보가 클리어링 하우스(Clearing House) 에 등록된다.
  * Clearing House : 디지털 저작권 중개 및 발급 ,결제 , 분배 수행장소
  * 콘텐츠 제공자 : 콘텐츠를 제공하는 저작권자
  * 패키저 : 콘텐츠를 메타 데이터와 함께 배포 가능한 형태로 묶어 암호화 
  * 콘텐츠 분배자 : 암호화된 콘텐츠를 유통하는 곳 (사람)
* 관리 기술 요소 : 암호화, 키관리, 암호화 파일 생성, 식별 기술, 저작권 표현 ,정책관리, 크랙 방지, 인증 등

#### 2. 소프트웨어 버전 관리 도구

* 공유 폴더 방식 : SCSS RCS PVCS QVCS 등
  * 개발 완료된 파일을 공유된 폴더에 매일 복사하는 것
  * 파일의 변경사항은 데이터베이스에 기록하여 관리
* 클라이언트/서버 방식 : CSV, SVN(Subversion), CVSNT, Clear Case, CMVC, Perforce
  * 모든 버전 관리는 서버에서 수행된다. ( 중앙 시스템 저장 관리 방식)
  * 하나의 파일을 서로 다른 개발자가 작업할 경우 경고 메시지 출력
* 분산 저장소 방식  : Git, GNU arch, DCVS, ... 등
  * 개발자별로 원격 저장소의 자료를 자신의 로컬 저장소로 복사하여 작업한 후 변경된 내용을 로컬 저장소로 우선 반영한 후 원격저장소에 반영하는 것.
  * 원격 저장소에 문제가 생겨도 로컬 저장소의 자료를 이용하여 작업 가능
* Subversion 서브버전 SVN
  * CVS 의 개선, 아파치 소프트웨어 재단에서 발표한 것
  * 클라이언트 / 서버 구조로 서버에 최신 버전의 파일들과 변경 내역이 관리
  * 서버의 자료를 클라이언트로 복사해 와 작업 한 후 서버에 반영 (Commit)
  * 커밋 할때마다 Revision 이 1 씩 증가
  * 서버는 주로 유닉스, 클라이언트는 다른 운영체제
  * 소스가 오픈, 무료사용 가능
  * 디렉터리 이름 변경 및 이동 가능
  * 명령어 정리
    * add , commit merge 는 알꺼고
    * checkout : 버전관리정보, 소스파일 받아옴
    * import :  처음 소스파일 저장 명령 , 한번만 씀
    * export : 버전관리 정보 제외 파일만 받아오기
* Git 깃 
  * add - Staging Area / commit - local / push - local to remote 
  * fetch : 원격 저장소의 변경 이력만을 지역 저장소로 가져와 반영
  * clone? : 지역 저장소로 복제
  * fork? : 원격 저장소로 복제 
  * Snapshot :  파일의 변화를 저장, 버전의 흐름 파악 가능
  * 지역 저장소와 원격 저장소로 관리.
  * 브랜치를 이용한 기본 버전관리, 테스트 버전관리 가능

#### 3. 빌드 자동화 도구

* Jenkins : JAVA 기반 오픈 소스, 서블릿 컨테이너에서 실행되는 서버 기반 도구, Web GUI 제공

  * 여러대의 컴퓨터를 이용한 3
  * 분산 빌드나 테스트 가능

* Gradle : Groovy 를 기반으로 오픈 소스 형태의 자동화 도구, 안드로이드 앱 개발 환경에서 사용

  * 실행할 처리 명령들을 모아 Task 로 만든 후 태스크 단위로 수행

  Jenkins - java, Gradel - Groovy



#### 예상 문제

* 애자일에서는 패키징이 주기가 끝날때마다 이루어짐

* 패키징에서의 모듈화? : 기능별로 코드를 분류하는 것

* 소프트웨어 버전 등록 과정?

  * Import - Check-out - Commit - Update - Diff

  



### 4장 애플리케이션 테스트 관리

> 테스트 기법, 개발 단계 , 통합 테스트 , 화이트박스 & 블랙박스 테스트, 테스트 케이스, 상향식 하향식..

* **Validation 확인**  : 고객의 요구사항에 맞게 만들어졌는가 ( 사용자 입장 )
* **Verification 검증** : 명세서에 맞게 만들어졌는가 ( 개발자 입장 )
* 테스트 실행 전에 소프트웨어 유형 분류, 특성을 정리해서 중점적으로 테스트할 사항을 정리

#### 정적 테스트  -> 오류 조기 검출을 위한 테스트

* 프로그램을 실행하지 않고 진행하는 테스트, 개발 초기에 결함 발견, 개발 비용 감소
* 워크스루(walkthrough 전문가에 의한 검토회의) , 인스펙션, 코드 검사
  * 오류의 조기 검출에 목적이 있음. 

#### 동적 테스트 -> 실행과정에서 오류를 찾는 테스트

* 프로그램을 실행하여 오류를 찾는 테스트, 개발 모든 단계에서 사용 가능
* **블랙박스 테스트** : 박스 안을 볼 수 없는 블랙박스 테스트 - **기능**이 완전히 작동되는 것을 입증하는 테스트
  * 요구사항 명세를 보며 테스트
  * 인터페이스에서 실시, 테스트 과정의 후반부에 적용
  * 동치 분할 검사 : 입력 자료에 초점을 맞춰 테스트 케이스를 만들고 검사 ( 타당한 입력 자료, 타당하지 않은 입력 자료를 넣어 검사)
  * 경계값 분석 : 입력 조건의 경계값 주변에서 오류가 발생할 확률이 높다는 점을 이용한 분석
  * 원인-효과 그래프 검사 : 입력 데이터 간의 관계와 출력에 영향을 미치는 상황을 체계적으로 분석, 효용성이 높은 테스트 케이스를 선정하여 검사
  * 오류 예측 검사 : 데이터 확인 검사, 과거의 경험 또는 확인자의 감각.. 
  * 비교 검사 : 여러 버전의 프로그램에 동일한 테스트 자료를 제공하여 동일한 결과가 출력 되는지 확인.
* **화이트박스 테스트** : 모듈의 원시 코드를 오픈시킨 상태에서 **논리적인 모든 경로(구조)**를 테스트.
  * 모듈 안의 작동을 직접 관찰, 모든 문장을 한 번 이상 실행, 논리적 경로 제어
  * 기초 경로 검사 : 실행 경로의 기초를 정의
  * 제어 구조 검사 : 논리적 조건 검사, 반복 구조 초점 루프 검사, 변수의 정의와 사용 위치 초점 데이터 흐름검사
  * 문장 검증 : 모든 구문이 한 번 이상 수행 되도록 테스트케이스 설계
  * 분기 검증 : 모든 조건문이 한 번 이상 수행되도록 테스트케이스 설계
  * 조건 검증 : 모든 조건문에 대해 True, False 검증 테스트케이스 설계
  * 분기/조건 : 모든 조건문과 조건문 안의 개별 조건식 결과 True, False 테스트케이스 설계

#### 개발 단계에 따른 테스트

* 단위 테스트 -> 통합 테스트 -> 시스템 테스트 -> 인수 테스트 

* 알파 테스트 : 사용자가 개발자 앞에서 행하는 테스트 (통제된 환경)

* 베타 테스트 : 여러 명의 사용자 앞에서 행하는 테스트 (통제 없음) 

* 통합 테스트 : 단위 테스트가 끝난 모듈을 통합하는 과정

  * 비점진적 통합 방식 : 모듈을 미리 결합시키고 그냥 바로 프로그램 전체 테스트 ( **빅뱅 통합**)
  * 점진적 통합 방식 : 모듈 단위를 단계적으로 결합 시키면서 테스트 ( 하향, 상향, 혼합식) 
    * 오류 수정이 용이하며 인터페이스와 관련된 오류를 완전히 테스트할 가능성이 높다.

* 하향식 통합 테스트 : 상위 모듈에서 하위 모듈로 내려가며 통합 ( 깊이우선, 넓이우선 )

  * 사용자에게 시스템 구조를 보여줄 수 있음.
  * 스텁!!! STUB - 상위 모듈은 있지만 하위모듈이 없을 때 대체
    * 일시적으로 필요한 조건만 가지고 임시로 제공되는 시험용 모듈을 일컫는다.

* 상향식 통합 테스트 : 하위모듈에서 상위 모듈로 통합.

  * 하위 모듈들을 클러스터로 결합하고, 상위 모듈에서 드라이버 를 작성, 클러스터 단위로 테스트.

    순서 : 모듈을 클러스터로 결합 -> 드라이버 작성 -> 클러스터 검사(테스트) -> 클러스터 상위 결합

  * 드라이버 : 상위 모듈 없이 하위 모듈이 있을 경우 하위 모듈을 구동.

* 혼합식 : 하위 수준에서는 상향식, 상위 수준에서는 하향식으로 하여 샌드위치식 통합

* 회귀 테스팅 : 이미 테스트된 프로그램에서 테스팅을 반복하여, 변경된 모듈의 오류를 찾는 방법.

* 실제 테스트 과정 

  * 테스트 계획 -> 테스트 분석(계획을 분석) -> 테스트 케이스 설계 -> 테스트 실행 -> 테스트 결과 분석(결과를 분석)

* Pareto 법칙 : 테스트에서 오류의80%는 전체 모듈의 20% 내에서 발견된다.

* 테스트 오라클 : 소프트 웨어의 테스트 결과가 올바른지 판단하기 위해 사전에 정의된 참 값.

### 5장 인터페이스 구현

>인터페이스 설계서, 인터페이스 보안, 모듈 설계... EAI, ESB,

#### 모듈 연계

* EAI  : Enterprise Application Language
  * EAI는 비즈니스 간 통합 및 연계성을 증대시켜 효율성 및 각 시스템 간의 확정성을 높여준다.
  * Point to Point : 애플리케이션을 1:1 로 연결
  * Hub & Spoke : 중앙 집중형 ( 허브에 스포크가 연결)
  * Message BUS ( ESB 방식) 
  * Hybrid : Hub& Spoke (중앙 집중형) 방식과 Message BUS 방식의 혼합. 
    * 내부에서는 중앙 집중형, 그룹 간에는 버스
* ESB : Enterprise Service Bus 
  * **서비스 중심의 통합**을 지향
  * 결합도를 약하게 유지한다.

* 내부 모듈? 외부 모듈?
  * 내부 : 회계 기능
  * 외부 : 인사 기능
* 인터페이스 기능 구현 
  * 컴포넌트 명세서
    * 컴포넌트의 개요 
    * 내부 클래스의 동작
    * 인터페이스를 통한 외부와 통신 (인터페이스 클래스)
  * 인터페이스 명세서
    * 인터페이스 클래스의 세부 조건 및 기능 등을 정의한 것.
    * 사전조건 / 사후조건 : 오퍼레이션 작동 전,후 항상 참이여야 하는 조건 --> 인터페이스 명세서에 있는 조건임.
    * 여기에 컴포넌트는 안들어있다!!!
  * 모듈 세부 설계서 : 컴포넌트와 컴포넌트 간 상호 작용을 정의한 인터페이스 명세서 + 컴포넌트 명세서



#### 인터페이스 구현 검증

> 인터페이스란 ? 
>
> 그냥 사용자가 만나는 모든 것들이라고 생각해도 무방하다. 메뉴, 도구모음, 화면 .. 기능을 하기위해 필요하거나, 연계되는 모든 것들.  ( Inter - Face : 얼굴을 마주하다 이런 느낌인듯 )



> 그럼 컴포넌트는 ?
>
> 소프트웨어 재사용에 사용되는 모든 객체의 집합 , 대규모 사용단위. : 객체 -> 클래스 -> 모듈 -> 컴포넌트 

* 인터페이스가 문제없이 작동하는지 확인하는 것.
* **검증** 도구 : 테스트 자동화 도구 사용
  * xUnit : Java 의 Junit, C++ 의 Cppunit , .Net의 Nunit 
  * STAF : 서비스 호출 및 컴포넌트 재사용
  * FitNesse : 웹 기반 테스트케이스 설계도구
  * NTAF (NHN NAVER) : FitNesses 와 STAF의 장점을 결합한 네이버의 테스트 자동화 도구
  * Selenium : 웹 어플리케이션 테스트 프레임워크.
  * watir : ruby 사용 어플리케이션 테스트 프레임워크 
* **감시** 도구 : APM 을 사용한 **모니터링**
  * 제니퍼 : 애플리케이션의 개발부터 오픈 운영 안정화까지 전 단계에 걸친 모니터링
  * 스카우터 : 애플리케이션 및 OS 자원에 대한 모니터링. (오픈소스)
* 인터페이스 보안 기능
  * 네트워크 Network, 애플리케이션 Application, 데이터베이스 Database 영역 에 적용
* 송수신 인터페이스 엔티티 동작시 발생할 수 있는 오류?
  * 데이터 정합성
  * 데이터 전송 주체의 논리적 오류
  * DB 커넥션 오류
  * 데이터 트랜섹션시 프로그램상 논리적 오류
* 인터페이스 객체 송 수신시 발생할 수 있는 예외
  * 송신 데이터 생성 시 프로세스의 논리적 결함
  * 네트워크 서버 불안정
  * 특수문자 파싱 오류
  * 수신 데이터 처리시 프로그램 논리적 결함